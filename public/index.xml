<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>violeta</title>
    <link>https://cheshireviolet.github.io/</link>
    <description>Recent content on violeta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-BR</language>
    <lastBuildDate>Tue, 03 Dec 2024 01:43:07 -0300</lastBuildDate>
    <atom:link href="https://cheshireviolet.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Compilando a Darknet no Windows 10 e treinando modelo com a YOLOv3</title>
      <link>https://cheshireviolet.github.io/blog/third/</link>
      <pubDate>Tue, 03 Dec 2024 01:43:07 -0300</pubDate>
      <guid>https://cheshireviolet.github.io/blog/third/</guid>
      <description>&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;AVISO:&lt;/strong&gt; Por mais que seja possível treinar um modelo utilizando a CPU, é um processo extremamente mais demorado do que poderia ser, pela sua própria sanidade, usa o Google Colab se possível. Ou alguma distro de linux.&lt;/p&gt;&#xA;&lt;p&gt;Um dos exercícios do Bootcamp de machine learning que estou realizando é realizar exatamente o que diz no título desse post. No caso, a parte de ser no windows é por eu ser cabeça dura demais para só usar o Google Collab e não ter problemas.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="introdução">Introdução</h2>
<p><strong>AVISO:</strong> Por mais que seja possível treinar um modelo utilizando a CPU, é um processo extremamente mais demorado do que poderia ser, pela sua própria sanidade, usa o Google Colab se possível. Ou alguma distro de linux.</p>
<p>Um dos exercícios do Bootcamp de machine learning que estou realizando é realizar exatamente o que diz no título desse post. No caso, a parte de ser no windows é por eu ser cabeça dura demais para só usar o Google Collab e não ter problemas.</p>
<p>Se você tentar seguir o tutorial da própria <a href="https://pjreddie.com/darknet/yolo/">Darknet</a>, é possível que você encare os mesmos problemas que eu encarei, então vou explicar como fiz tudo funcionar.</p>
<p>Além disso, essa também é a própria resolução do exercício, uau estamos unindo o útil ao agradável.</p>
<p>Antes de prosseguirmos, caso tenha interesse no artigo sobre a YOLOv3 escrito pelos seus criadores, recomendo <a href="https://arxiv.org/abs/1804.02767">YOLOv3: An Incremental Improvement</a> (está em inglês).</p>
<h2 id="requerimentos">Requerimentos</h2>
<ul>
<li><a href="https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community">Microsoft Visual Studio</a> (Não testei o code, mas talvez funcione)</li>
<li><a href="https://cmake.org/download/">CMake GUI</a></li>
<li>A própria <a href="https://github.com/AlexeyAB/darknet/archive/master.zip">Darknet</a></li>
<li><a href="https://sourceforge.net/projects/opencvlibrary/">OpenCV</a> (Opcional)</li>
<li><a href="https://developer.nvidia.com/cuda-downloads">CUDA</a> (Opcional, precisa ter <strong>GPU DA NVIDIA</strong>, é doloroso se não tiver)</li>
</ul>
<h2 id="compilando-a-darknet">Compilando a Darknet</h2>
<ol>
<li>Extraia o darknet-master.zip</li>
<li>Instale os programas da lista que não foram instalados</li>
<li>Abra o CMake GUI</li>
<li>Browse source -&gt; Selecione a pasta aonde extraiu a darknet.</li>
<li>Browse Build -&gt;  Selecione a pasta aonde quer que seja criada a solução (.sln)</li>
<li>Configure irá carregar todas as opções de configuração da Solução.</li>
<li><strong>Opcional:</strong> Se não for usar CUDA/OpenCV, desmarque as opções ENABLE_CUDA e ENABLE_OPENCV</li>
<li>Generate irá criar a solução no diretório especificado -&gt; Open Project irá abrir a solução no visual studio.</li>
<li>Build Solution (F6) como Release para x64.</li>
</ol>
<p>Os binários estarão na pasta Release no diretório do .sln.</p>
<h2 id="baixando-o-coco-dataset">Baixando o COCO Dataset</h2>
<p>Pelo próprio <a href="https://cocodataset.org/#download">site do COCO</a> eles tem alguns tutoriais de como baixar usando a COCO API, MASK API e através da FiftyOne. Para fins práticos (ou não), estarei seguindo o tutorial do próprio site da Darknet.</p>
<p>Dentro do <em>darknet-master/scripts/</em> tem um arquivo chamado <em>get_coco_dataset.sh</em>, abrindo com um editor de texto, você vai ver que primeiro o arquivo clona a COCO API e cria uma pasta chamada <em>images</em> logo após. Se não tiver git instalado, basta baixar o repositório zipado, igual feito com a darknet.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">git clone https://github.com/pdollar/coco
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">cd</span> coco
</span></span><span class="line"><span class="ln">3</span><span class="cl">mkdir images</span></span></code></pre></div><p>Então ele usa <strong>wget</strong> para baixar alguns arquivos, por fins práticos é mais rápido baixar só clicando neles, mesmo (se não tiver wget para Windows instalado, claro)</p>
<ul>
<li>Os arquivos abaixo são extraídos dentro da pasta images, que acabamos de criar.
<ul>
<li>train2014.zip</li>
<li>val2014.zip</li>
</ul>
</li>
<li>E os arquivos abaixo ficam dentro do diretório da Coco
<ul>
<li>instances_train-val2014.zip</li>
<li>5k.part</li>
<li>trainvalno5k.part</li>
<li>labels.tgz</li>
</ul>
</li>
</ul>
<p>Não colocarei links pois é possível que na data que esteja lendo eles tenham expirado ou até mesmo os trocado (até porque o dataset de 2014 está meio desatualizado, né?). Baixe tudo, é possível que <strong>demore um pouco</strong> (os datasets de treino e validação são bem pesadinhos)</p>
<p>Extraia que foi baixado tudo na pasta aonde Buildou a Darknet. O arquivo labels.tgz gera um arquivo labels.tar. É basicamente um Zip dentro de um Zip, 7Zip descomprime. :</p>
<p>Para finalizar, o script concatena o diretório atual com cada linha dos arquivos e coloca tudo em dois arquivos de texto.</p>
<p>Você pode usar os seguintes comandos no Powershell para realizar essa parte final do script:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Powershell" data-lang="Powershell"><span class="line"><span class="ln">1</span><span class="cl"><span class="nb">Get-Content</span> <span class="p">.\</span><span class="n">5k</span><span class="p">.</span><span class="py">part</span> <span class="p">|</span> <span class="nb">ForEach-Object</span> <span class="p">{</span> <span class="s2">&#34;</span><span class="nv">$PWD</span><span class="s2">\</span><span class="p">$(</span><span class="nv">$_</span> <span class="o">-replace</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;\&#39;</span><span class="p">)</span><span class="s2">&#34;</span> <span class="o">-replace</span> <span class="s1">&#39;\\+&#39;</span><span class="p">,</span> <span class="s1">&#39;\&#39;</span> <span class="p">}</span> <span class="p">&gt;</span> <span class="n">5k</span><span class="p">.</span><span class="py">txt</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">Get-Content</span> <span class="p">.\</span><span class="n">trainvalno5k</span><span class="p">.</span><span class="py">part</span> <span class="p">|</span> <span class="nb">ForEach-Object</span> <span class="p">{</span> <span class="s2">&#34;</span><span class="nv">$PWD</span><span class="s2">\</span><span class="p">$(</span><span class="nv">$_</span> <span class="o">-replace</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;\&#39;</span><span class="p">)</span><span class="s2">&#34;</span> <span class="o">-replace</span> <span class="s1">&#39;\\+&#39;</span><span class="p">,</span> <span class="s1">&#39;\&#39;</span> <span class="p">}</span> <span class="p">&gt;</span> <span class="n">trainvalno5k</span><span class="p">.</span><span class="n">txt</span></span></span></code></pre></div><h2 id="configurando-a-darknet-para-treinamento-com-a-coco">Configurando a darknet para treinamento com a COCO</h2>
<p>Dentro de <em>darknet-master</em> existe uma pasta chamada <em>cfg</em> e outra chamada <em>data</em>. Copie ambas e cole-as dentro de <em>Release</em>. Dentro de <em>cfg</em>, nós precisamos editar o arquivo <em>coco.data</em></p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">classes = 80
</span></span><span class="line"><span class="ln">2</span><span class="cl">train = Caminho até trainvalno5k.txt
</span></span><span class="line"><span class="ln">3</span><span class="cl">valid = Caminho até 5k.txt
</span></span><span class="line"><span class="ln">4</span><span class="cl">names = Caminho para data/coco.names (A pasta que acabou de copiar)
</span></span><span class="line"><span class="ln">5</span><span class="cl">backup = backup
</span></span><span class="line"><span class="ln">6</span><span class="cl">eval = coco</span></span></code></pre></div><p>Também precisamos editar o arquivo <em>yolo.cfg</em>, já que está configurado para testes, e não treinamento.</p>
<p>Altere as linhas abaixo:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cfg" data-lang="cfg"><span class="line"><span class="ln">1</span><span class="cl"><span class="na">batch</span><span class="o">=</span><span class="s">64</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="na">subdivisions</span><span class="o">=</span><span class="s">8</span></span></span></code></pre></div><p>Copie o arquivo <em>pthreadVC2.dll</em> da pasta <em>darknet-master\3rdparty\pthreads\bin</em> para a pasta Release.</p>
<p>Só falta um ultimo arquivo, o <a href="https://pjreddie.com/media/files/darknet53.conv.74">darknet53.conv.74</a>, que é um arquivo pre-treinado de pesos. Coloque-o em Releases.</p>
<h2 id="treinando-o-modelo-finalmente">Treinando o Modelo, finalmente</h2>
<p>No powershell, basta executar:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Powershell" data-lang="Powershell"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">./</span><span class="n">darknet</span> <span class="n">detector</span> <span class="n">train</span> <span class="p">*</span><span class="n">caminho</span> <span class="n">completo</span><span class="p">*\</span><span class="n">cfg</span><span class="p">\</span><span class="n">coco</span><span class="p">.</span><span class="py">data</span> <span class="p">*</span><span class="n">caminho</span> <span class="n">completo</span><span class="p">*\</span><span class="n">cfg</span><span class="p">\</span><span class="n">yolov3</span><span class="p">.</span><span class="py">cfg</span> <span class="n">darknet53</span><span class="p">.</span><span class="py">conv</span><span class="p">.</span><span class="mf">74</span></span></span></code></pre></div><p>Trocando o caminho completo pelo&hellip;caminho completo&hellip;</p>
<p>Esse processo vai demorar&hellip;muitos dias&hellip;por favor não cometa o mesmo erro que eu.</p>
<p>Após treinado, será gerado um arquivo .weight, que pode ser utilizado para detecções, como no exemplo abaixo:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">./darknet detect cfg/yolov3.cfg *arquivo.weight* data/dog.jpg</span></span></code></pre></div><h2 id="bônus-ah-mas-eu-tenho-uma-placa-da-amd">Bônus: AH MAS EU TENHO UMA PLACA DA AMD</h2>
<p>Existe um repositório feito pra isso, mas não sei se é por estar desatualizado ou outro motivo, simplesmente não consigo compilar.</p>
<p>Talvez faça um post no futuro com uma solução, mas até lá, se quiser se aventurar é só <a href="https://github.com/sowson/darknet?tab=readme-ov-file">clicar aqui</a>.</p>
<h2 id="conclusão">Conclusão</h2>
<p>Da próxima vez irei comprar uma placa da NVIDIA.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Leetcode 128. Longest Consecutive Sequence</title>
      <link>https://cheshireviolet.github.io/blog/second/</link>
      <pubDate>Mon, 02 Dec 2024 01:50:58 -0300</pubDate>
      <guid>https://cheshireviolet.github.io/blog/second/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;&#xA;&lt;p&gt;Recentemente eu comecei a fazer os desafios do leetcode criado como &lt;a href=&#34;https://leetcode.com/studyplan/top-interview-150/&#34;&gt;problemas de entrevistas da FAANG&lt;/a&gt;, tanto pra refrescar noções de estruturas de dados quanto para praticar python, já que de modo geral por mim faço tudo em C#.&lt;/p&gt;&#xA;&lt;p&gt;Aproveitar a introdução para agradecer a &lt;a href=&#34;https://navendu.me/posts/adding-diagrams-to-your-hugo-blog-with-mermaid/&#34;&gt;este post&lt;/a&gt; pelo tutorial de como implementar mermaid em um fórum feito em hugo, graças ao post não precisei desenhar as árvores, e sim usar markdown :D&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="intro">Intro</h2>
<p>Recentemente eu comecei a fazer os desafios do leetcode criado como <a href="https://leetcode.com/studyplan/top-interview-150/">problemas de entrevistas da FAANG</a>, tanto pra refrescar noções de estruturas de dados quanto para praticar python, já que de modo geral por mim faço tudo em C#.</p>
<p>Aproveitar a introdução para agradecer a <a href="https://navendu.me/posts/adding-diagrams-to-your-hugo-blog-with-mermaid/">este post</a> pelo tutorial de como implementar mermaid em um fórum feito em hugo, graças ao post não precisei desenhar as árvores, e sim usar markdown :D</p>
<h2 id="o-problema-da-vez">O problema da vez</h2>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&amp;envId=top-interview-150">Dada uma array não ordenada de inteiros <em>nums</em>, retorne o tamanho da sequencia mais longa de valores consecutivos.</a></p>
<p>Exemplo:</p>





<pre tabindex="0"><code>Input: nums = [100,4,200,1,3,2]
Output: 4
Explicação: A sequencia mais longa de valores consecutivos é [1,2,3,4], o que torna a resposta 4.</code></pre><p><strong>Todos os exemplos desse post vão usar o input acima como base</strong> (sim, adicionei essa linha de texto após repetir algumas vezes que tava usando o exemplo acima)</p>
<p>A solução mais simples é ordenar a array, mas além de chata, é uma resposta pouco eficiente.</p>
<p>Na classificação do plano de estudos, esse problema está na lista de Hashmaps, porém, nas tags, está o termo <em>Union Find</em>, que eu nunca tinha ouvido falar antes.</p>
<h2 id="union-find-teoria">Union Find: Teoria</h2>
<p>O resumo é que você separa os valores por critérios, gerando uma árvore muito eficiente de ser percorrida.</p>
<p>Exemplo:</p>
<div class="mermaid">
flowchart TD
  1 --> 2 --> 3 --> 4
  100
  200
</div>

<p><em>Tá, mas e aí?</em> Esse algoritmo é interessante porque ele possui duas funções: Union e Find (criatividade torando). É aí que vem a brincadeira de verdade:</p>
<h3 id="findn">Find(n)</h3>
<p>Sempre irá retornar a raiz do nodo. Find(4) retornaria 1, Find(1) retornaria 1.</p>
<p>Uma coisa importante dessa estrutura é que para fins práticos, o parente da raiz será sempre a própria raiz.</p>
<p>Para implementar, é bem simples:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Parent</span><span class="p">):</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="k">if</span> <span class="n">Parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span> <span class="c1">#se não for a raiz</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">Parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="c1">#repete a função, porém com o Parent de parâmetro</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">        <span class="k">return</span> <span class="n">x</span> <span class="c1">#se for a raiz, retorna ela mesma</span></span></span></code></pre></div><h3 id="unionxy">Union(x,y)</h3>
<p>Junta dois grupos, a partir de suas raízes.</p>
<p>Exemplo: Union(4,200) alteraria a raiz de 200 para 1, que é a raiz de 4.</p>
<div class="mermaid">
flowchart TD
  1 --> 2 --> 3 --> 4
  1 --> 200
  100
</div>

<p>Outra implementação simples:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">Parent</span><span class="p">):</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">Parent</span><span class="p">[</span><span class="n">Find</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></span></span></code></pre></div><h2 id="resolvendo-o-problema">Resolvendo o problema</h2>
<p>É minha primeira vez resolvendo um problema usando Union Find, então é possível que minha resposta não esteja optimizada, ainda assim fiquei contente com o resultado.</p>
<p>A galera do leetcode gosta bastante de colocar casos excepcionais, porém válidos, nos testes, então logo de cara:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="n">nums</span> <span class="o">==</span> <span class="p">[]:</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">        <span class="k">return</span> <span class="mi">0</span></span></span></code></pre></div><p>Ok, podemos começar a resolução real, agora. Declarando as 3 variáveis que serão usadas:</p>
<ul>
<li><em>graph</em> é um dicionário aonde sua chave é <em>nums[i]</em>, e o valor é a raiz de <em>nums[i]</em></li>
<li><em>graph_sum</em> é um dicionario aonde sua chave é <em>nums[i]</em> e o valor é o tamanho da sua sequência</li>
<li><em>longest</em> é o tamanho da sequencia mais longa</li>
</ul>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">graph</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">graph_sum</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span></span></span></code></pre></div><p>Find e Union, conforme a estrutura que estamos lidando</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="k">return</span> <span class="n">i</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">root_i</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">root_j</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">graph</span><span class="p">[</span><span class="n">root_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_j</span></span></span></code></pre></div><p>E agora a parte que importa, que é bem pequena na verdade:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        <span class="n">graph_sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            <span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">            <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">if</span> <span class="n">longest</span> <span class="o">&lt;</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">longest</span> <span class="o">=</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="k">return</span> <span class="n">longest</span></span></span></code></pre></div><p>Vamos quebrar por partes, pra simplificar. Primeiro, se o item ainda não existe em nossa árvore, adicionamos ele, com a raiz sendo ele mesmo.
Também adicionamos no dicionário de sequencias, sua sequencia sendo 1.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">graph_sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span></span></span></code></pre></div><p>Ainda dentro do if acima, para evitar duplicidade, se suas sequencias existem (i-1 e i+1) na arvore, realizamos o Union, e então adicionamos o tamanho da sequencia que foi adicionada a raiz.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></span></span></code></pre></div><p>E por fim, se o tamanho da sequencia atual for maior que a maior sequencia registrada, atualizamos o <em>longest</em> para a nova maior sequencia. Então o loop continua com o próximo item da lista de entrada, e retorna o valor de <em>longest</em></p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="n">longest</span> <span class="o">&lt;</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">        <span class="n">longest</span> <span class="o">=</span> <span class="n">graph_sum</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">return</span> <span class="n">longest</span></span></span></code></pre></div><h2 id="conclusão">Conclusão</h2>
<p>Sinto que realizei algum teste de entrevista que tinha um problema parecido, ou que pelo menos eu poderia ter usado Union Find pra chegar em uma solução mais eficiente.</p>
<p>Após uma pesquisada, realmente é algo que é visto com certa frequência em entrevistas, então vale muito a pena dar uma olhada e brincar!</p>
]]></content:encoded>
    </item>
    <item>
      <title>O primeiro post é sempre o mais confuso</title>
      <link>https://cheshireviolet.github.io/blog/first/</link>
      <pubDate>Wed, 27 Nov 2024 20:35:43 -0300</pubDate>
      <guid>https://cheshireviolet.github.io/blog/first/</guid>
      <description>&lt;p&gt;Bom, vamo lá né. Primeiro post é sempre complicado, você tem que se apresentar, mas já tem uma micro apresentação na página inicial. Palavras são difíceis, porque introdução nunca é o que você realmente quer falar sobre.&lt;/p&gt;&#xA;&lt;p&gt;A ideia de criar esse blog surgiu da vontade de falar sobre meus projetos, porém fora do padrão microblogging. Às vezes você tem uma idéia muito boa porém despedaçar em mini posts e futuramente perder tudo é&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;chato.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Bom, vamo lá né. Primeiro post é sempre complicado, você tem que se apresentar, mas já tem uma micro apresentação na página inicial. Palavras são difíceis, porque introdução nunca é o que você realmente quer falar sobre.</p>
<p>A ideia de criar esse blog surgiu da vontade de falar sobre meus projetos, porém fora do padrão microblogging. Às vezes você tem uma idéia muito boa porém despedaçar em mini posts e futuramente perder tudo é&hellip;&hellip;&hellip;&hellip;chato.</p>
<p>Ao mesmo tempo tenho trabalhado em formas de manter o foco e observar meu progresso, e um blog é exatamente isso.</p>
<p>Também é <del>, em teoria,</del> uma forma de espalhar conhecimento adiante. Nunca se sabe quando alguém do nada acha um post seu com uma solução para um problema.</p>
<p>Enfim, não faço ideia do quão longe esse blog vai, mas é mais um passo pra frente.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
